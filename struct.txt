Below I’ll give you an action plan (what to do next, prioritized), followed by copy-paste artifacts you can drop into the repo immediately:

go.mod (starter)

Makefile (dev shortcuts)

a sample unit test (wallet_test.go) you can extend

a GitHub Actions CI workflow to run tests + lint + race detector

concrete next priorities and recommended fixes taken from your README

Do not paste everything willy-nilly — run the Makefile steps and CI will pick it up. Let’s go.

1) Immediate prioritized actions (do these now)
Add module metadata and lock deps (go.mod / go.sum).

Add dev Makefile so everyone runs the same commands.

Add CI to run go test ./... -race -cover + golangci-lint.

Add unit tests for missing modules (start with mempool, miner, net stubs).

Harden crypto & tx format (canonical signatures / low-s / DER or standardized encoding).

Implement persistence safety / graceful shutdown tests (DB close, miner stop).

Add property tests for consensus invariants (use gopter or go’s fuzzing).

Address README security TODOs incrementally; track them as issues.

2) Drop-in files (copy/paste)
go.mod
Replace module github.com/you/gochain with your module path.

go
Copy
Edit
module github.com/you/gochain

go 1.20

require (
    github.com/libp2p/go-libp2p v0.28.6 // only if using p2p tag
    github.com/dgraph-io/badger/v4 v4.0.6 // only if using db tag
    github.com/spf13/cobra v1.7.0
    github.com/spf13/viper v1.16.0
    github.com/stretchr/testify v1.8.4
    github.com/onsi/gomega v1.20.0
    github.com/leanovate/gopter v0.0.0-20210801000000-... // optional property testing
)

replace (
    // Add replaces if you have local forks; otherwise remove
)
Run to fetch deps and generate go.sum:

bash
Copy
Edit
go mod tidy
Makefile
Save at repo root. Minimal, useful targets.

makefile
Copy
Edit
.PHONY: all test lint build clean run bench

BINARY = gochain
PKGS = ./pkg/...

all: build

# build full node (requires tags)
build:
	@echo "Building (p2p, db) binary..."
	go build -tags='p2p db' -v ./cmd/$(BINARY)

# fast build of libs only
build-core:
	go build ./pkg/...

test:
	go test $(PKGS)

test-verbose:
	go test -v $(PKGS)

test-race:
	go test -race ./...

test-cover:
	go test -coverprofile=coverage.out ./... && go tool cover -html=coverage.out

lint:
	@golangci-lint run ./...

fmt:
	gofmt -w .

run: build
	./$(BINARY) --config ./config/config.yaml --port 30303 --mining

bench:
	go test -bench=. ./...

clean:
	@rm -f $(BINARY) coverage.out
Sample unit test for wallet: pkg/wallet/wallet_test.go
Start here and expand. Requires your wallet package API to match — adapt names if different.

go
Copy
Edit
package wallet

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestKeygenSignVerify(t *testing.T) {
	// generate keys
	priv, pub, err := NewKeyPair() // adapt to your API
	require.NoError(t, err)
	require.NotNil(t, priv)
	require.NotNil(t, pub)

	msg := []byte("hello gochain")
	sig, err := Sign(priv, msg)
	require.NoError(t, err)
	require.NotNil(t, sig)

	ok, err := Verify(pub, msg, sig)
	require.NoError(t, err)
	require.True(t, ok, "signature should verify")
}

func TestAddressDerivationRoundtrip(t *testing.T) {
	priv, pub, err := NewKeyPair()
	require.NoError(t, err)

	addr := AddressFromPubKey(pub)
	require.NotEmpty(t, addr)

	// If you have an AddressToPub helper or a wallet store, test roundtrip where applicable
	_ = priv
	_ = addr
}
Run: make test-verbose or go test ./pkg/wallet -v

GitHub Actions CI: .github/workflows/ci.yaml
A baseline CI to run tests, race detector, and lint (adjust to repo).

yaml
Copy
Edit
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.20

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Install golangci-lint
        run: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $GOPATH/bin v1.59.0

      - name: Run go fmt
        run: go fmt ./...

      - name: Run unit tests
        run: go test ./... -v

      - name: Run race detector
        run: go test -race ./...

      - name: Run linters
        run: golangci-lint run ./...
3) Commands to run locally (copy/paste order)
bash
Copy
Edit
# init and fetch
go mod tidy

# build core packages fast
make build-core

# run unit tests
make test-verbose

# run race detector (slower but critical)
make test-race

# run coverage / show html
make test-cover

# run lint (install golangci-lint first)
make lint
4) Concrete security / correctness fixes to prioritize (based on your README)
Switch to secp256k1 (or make ECDSA choice configurable). Use vetted libraries (e.g., btcd/btcec or decred/dcrd/dcrec/secp256k1/v4). If you keep P-256, call that out explicitly but expect ecosystem friction.

Canonical signature format — enforce DER or r||s canonicalization and low-s enforcement to avoid malleability.

Persistent keystore — implement encrypted disk keystore, AES-GCM + PBKDF2/Argon2.

UTXO / account model — implement and test the mechanism for preventing double-spends; choose one model and be consistent.

Improve difficulty retargeting — implement windowed median and sanity checks (upper/lower bounds).

Network message validation — sign and verify critical messages; add peer scoring and rate limiting.

DB safety — atomic writes and graceful shutdown with context cancellation; add DB migration/versioning.

Add integration tests for graceful restart — spin up node, mine tx, shutdown, restart, ensure blockstore is intact.

5) Test coverage & property tests
Add property tests for:

Chain reorg invariants (no duplication, UTXO consistency).

Difficulty monotonicity and target correctness.

Use built-in fuzzing (go test -fuzz=Fuzz...) for tx encoding/decoding.

6) Next feature & docs checklist (small PRs)
Make small focused PRs with titles like:

feat(storage): add Badger-backed blockstore with atomic writes

fix(wallet): switch to secp256k1 and canonical DER signatures

test(mempool): add eviction and conflict resolution tests

ci: add race detector and golangci-lint

Each PR should include:

unit tests

changelog entry (short)

README updates if API changed

7) Final notes & direct challenge
You’ve got a great educational codebase. Now: stop treating it like a monolith — split work into focused PRs, add CI gating, and force tests before merges. Fix crypto and transaction model early; everything else depends on those invariants.

Challenge: Ship the next PR within 48 hours that replaces your ephemeral wallet with a disk keystore (encrypted) and adds unit tests proving keys are persisted and signatures still verify. Want me to generate that keystore code + tests now? Say the word and I’ll lay it out, ready to paste into pkg/wallet.
